#!/usr/bin/env python3
# controller
import os
import socket
import json
import sys
import threading

def match_pattern(path, pattern):
    """
    Match path against pattern with ** (recursive) and * (single level) support.
    """
    # Expand ~ to home directory
    pattern = os.path.expanduser(pattern)
    path = os.path.abspath(path)
    
    if '**' in pattern:
        # /etc/** means anything under /etc/
        prefix = pattern.replace('/**', '')
        return path == prefix or path.startswith(prefix + '/')
    elif '*' in pattern:
        import fnmatch
        return fnmatch.fnmatch(path, pattern)
    else:
        return path == pattern

def path_allowed(path, profile):
    """
    Check if path is allowed by policy.
    Logic: DENY if in denied_paths, else ALLOW if in allowed_paths, else DENY
    """
    for pat in profile.get("denied_paths", []):
        if match_pattern(path, pat):
            return False
    
    allowed = profile.get("allowed_paths", [])
    if not allowed:
        return False
    
    for pat in allowed:
        if match_pattern(path, pat):
            return True
    
    return False

def exec_allowed(executable, profile):
    """
    Check if executable is allowed by policy.
    Logic: denied_executables checked first, then must match allowed_executables.
    """
    allowed = profile.get("allowed_executables", [])
    denied = profile.get("denied_executables", [])
    
    # Check denied first
    for pattern in denied:
        if match_pattern(executable, pattern):
            return False
    
    # If no allowed list specified, allow all (that aren't denied)
    if not allowed:
        return True
    
    # Must match at least one allowed pattern
    for pattern in allowed:
        if match_pattern(executable, pattern):
            return True
    
    return False


def handle_file(evt, profile):
    fpath = evt.get("detail", "")
    pid = evt.get("pid", 0)
    
    if path_allowed(fpath, profile):
        print(f"[ALLOW] pid={pid} file {fpath}", flush=True)
        return {"verdict": "allow"}
    else:
        print(f"[DENY] pid={pid} file {fpath}", flush=True)
        return {"verdict": "deny"}

def handle_net(evt, profile):
    pid = evt.get("pid", 0)
    detail = evt.get("detail", "")
    
    if profile.get("allow_network", False):
        print(f"[ALLOW] pid={pid} net {detail}", flush=True)
        return {"verdict": "allow"}
    else:
        print(f"[DENY] pid={pid} net {detail}", flush=True)
        return {"verdict": "deny"}

def handle_client(conn, profile):
    try:
        data = conn.recv(4096).decode('utf-8').strip()
        event = json.loads(data)
        
        etype = event.get("type")
        detail = event.get("detail", "")
        pid = event.get("pid", "?")
        
        verdict = "allow"
        
        if etype == "file":
            if not path_allowed(detail, profile):
                verdict = "deny"
                print(f"[DENY] pid={pid} file {detail}")
            else:
                print(f"[ALLOW] pid={pid} file {detail}")
        
        elif etype == "net":
            if not profile.get("allow_network", False):
                verdict = "deny"
                print(f"[DENY] pid={pid} net {detail}")
            else:
                print(f"[ALLOW] pid={pid} net {detail}")
        
        # NEW: handle exec events
        elif etype == "exec":
            if not exec_allowed(detail, profile):
                verdict = "deny"
                print(f"[DENY] pid={pid} exec {detail}")
            else:
                print(f"[ALLOW] pid={pid} exec {detail}")
        
        else:
            print(f"[WARN] unknown event type: {etype}")
        
        response = json.dumps({"verdict": verdict}) + "\n"
        conn.send(response.encode('utf-8'))
    except Exception as e:
        print(f"[controller] client error: {e}", flush=True)
    finally:
        conn.close()

def main():
    if "POLICY_JSON" not in os.environ or "SAFERUN_SOCK" not in os.environ:
        print("POLICY_JSON and SAFERUN_SOCK must be set", flush=True)
        sys.exit(1)
    
    profile = json.loads(os.environ["POLICY_JSON"])
    sock_path = os.environ["SAFERUN_SOCK"]
    ready_path = os.environ.get("SAFERUN_READY", sock_path + ".ready")
    
    if os.path.exists(sock_path):
        try:
            os.unlink(sock_path)
        except:
            pass
    
    s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(sock_path)
    s.listen(16)
    os.chmod(sock_path, 0o600)
    
    print(f"[controller] policy loaded: {profile}", flush=True)
    print(f"[controller] listening on {sock_path}", flush=True)
    
    with open(ready_path, 'w') as f:
        f.write(str(os.getpid()))
    
    print(f"[controller] ready (signaled via {ready_path})", flush=True)
    
    try:
        while True:
            try:
                conn, _ = s.accept()
                t = threading.Thread(target=handle_client, args=(conn, profile), daemon=True)
                t.start()
            except Exception as e:
                print(f"[controller] accept error: {e}", flush=True)
    finally:
        try:
            os.unlink(ready_path)
        except:
            pass

if __name__ == "__main__":
    main()